\documentclass[a4paper,twoside,titlepage]{article}
\usepackage[top=3cm,bottom=3cm,left=3cm,right=3cm]{geometry}
\usepackage{url}

\renewcommand\familydefault{\sfdefault}

\title{Advanced Filesystem Layout}
\author{Magnus Achim Deininger}


\begin{document}
\maketitle
\tableofcontents

\newpage

\section*{Preface}
\addcontentsline{toc}{section}{Preface}
Current filesystem layouts employed by contemporary operating systems suffer
from a number of shortcomings. Among the more common of these are general
inconsistencies and issues with contemporary multi-architecture systems. Minor,
similar issues occur when trying to develop for architectures other than that of
the host system. In general, it is becoming increasingly common that binaries
(executables and libraries) of distinct systems occur together on a single
system. Examples for these would include contemporary desktop systems with
``64-bit'' capabilities mixing binaries compiled for x86-64 and x86-32 on the
same filesystem with poor separation, or average Linux installations containing
binaries intended for Microsoft Windows for use with WINE, or FreeBSD
installations including binaries intended for Linux.

This has lead to what may be perceived as inconsistencies in order to fix some
of these issues, such as the lib/lib32/lib64 dilemma that would require sane
software build scripts to figure out in which of these directories to put
created libraries. This alone is already inconsistent with requirements that
expressly forbid this -32/-64 extension on bin/ directories\footnote{See the FHS
document for details.}, and the idea itself seems rather hackish.

Additionally, the original reasoning behind a split of the root filesystem and
the /usr hierarchy (and also somewhat the /opt and /usr/local hierarchies) seems
to have been to be able to separate machine-local binaries and configuration
from site-local binaries and shared data and read-only from read-write data.
Originally a physical separation between the hierarchies was necessary, but due
to the ability of contemporary operating systems to unify multiple filesystem
hierarchies, sometimes called "union mounts", this division seems quite obsolete
\footnote{Operating Systems such as Plan 9 seem to agree with this.}.

This paper will try to explore an alternative filesystem hierarchy scheme that
should provide consistency for years to come. Keep in mind that this is a draft,
not yet a final document.

\newpage

\section{The Advanced Filesystem Layout}
The general idea behind this filesystem layout is fairly simple: "traditional"
directories are at the end of an arbitrarily long list of host specifications.
This leads to a general layout that looks something like this:
$os/architecture/subarchitecture/(bin|lib)$. The idea is to get more and more
specific along the path, with the operating system being considered less
specific than the hardware architecture. This latter choice is fairly random,
but it seems to be easier or more common to run binaries from a different
architecture on the same operating system than it is to run binaries from a
different operating system even when on the same architecture (although there
are legimitate examples of both).

\subsection{Hierarchical Elements}

\subsubsection{/($os$/)?($architecture$/)?($subarchitecture$/)*: Architecture
Classification}

\subsubsection{/medium/($mediumname$)[0-9]*: Storage Media}
Mountpoints for storage media belong under this

\subsubsection{/home/($username$): Home Directories}

\subsubsection{/service/($servicename$): Services}

\subsubsection{/dev, /proc, /sys, /net, (...): Special Kernel Filesystems}
These obviously have operating-system specific meaning and layout. They usually
need to be kept in place (for example sysfs on Linux is specifically documented
as being required to be mounted on /sys). Obviously only nodes that are actually
going to be mounted need to be created.

\subsection{Terminal Path Elements}

\subsubsection{.+/bin: Binaries}
All binaries (`executables') go into this directory. No exceptions, not even for
``system binaries'', which would traditionally end up in /sbin. If you need
finer-grained control or systematic clustering of related binaries, you could
just use a subdirectory in /service instead.

\subsubsection{.+/lib: Libraries}

\subsubsection{.+/configuration or .+/etc: Configuration Files}

\subsubsection{.+/documentation or .+/doc: Documentation}

\subsubsection{.+/temporary or .+/tmp: Temporary Storage}

\subsubsection{.+/work: Intermediary Storage}

\subsection{Notable Differences to the FHS}

\subsubsection{.+/sbin vs .+/bin}
/sbin is pointless: system binaries may sound like a nice thing to hide from
users, but deciding which of the binaries are system binaries and which are
regular binaries is fairly arbitrary. For example the `ifconfig' programme is
often put in /sbin instead of /bin, although there are legitimate uses of
ifconfig for regular users. The programme's query functions immediately come to
mind. Since this functionality works fine for regular users, they can just
access the programme by entering the complete path, so the ``hiding'' was both
point- and fruitless.

Additionally the split is nearly impossible to perform systematically on
operating systems that have finer-grained access control than a simple root/user
divide. Operating systems like Plan9 or Linux\footnote{This may not seem obvious
at first, but internally the Linux kernel is documented to use so-called
`capabilities' that provide fine-grained access control to privileged functions}
come to mind. With these operating systems, half the users would probably end up
with /sbin in their path anyway since they'd have legitimate use for some system
programme or another.

For these reasons, there is no /sbin with this layout. If you really want to
hide system binaries, use filesystem namespaces and union mounts instead, but
remember that hiding them really is pointless.

\subsubsection{/var/tmp vs /work}

\subsubsection{/media vs /medium}
/media was quite an odd inconsistency. Virtually everything else used words or
abbreviations in the singular form, this is about the only place where a plural
was used. The idea to split it up was good though, so there we go.

\subsubsection{/var, /opt and /usr}

\newpage

\section{Issues with Legacy Systems}
There are some obvious incompatibilities with legacy filesystem layouts, at
least when employing the more descriptive paths.

\subsection{POSIX Compatibility Considerations}
The most notable problem to be encountered with live multi-host setups is the
likely lack of an appropriate /bin/sh binary. It should be possible to
circumvent this issue with either automatically created symlinks on boot or
with strategic application of namespaces.

It should be noted that this problem is easily be underestimated. Current BSD
and Linux systems, for example, employ a large amount of shell scripting for
common functionality, including things such as the ``init scripts'' that are
responsible for bringing up system services. In these script files, the first
line starts with a shabang, followed by the path to a script interpreter. Since
POSIX guarantees that /bin/sh is a valid shell script interpreter, scripts `out
in the wild' will rely on this and reference this location. The same applies to
the system() function in the standard C library.

\subsection{Booting}
During bootup the kernel needs to find and execute any binaries on the root
filesystem that are required to boot into userspace. With most other fielsystem
layouts, this is easily done, as the binaries were usually always in the same,
so it's just a matter of hardcoding the location, however with this new layout
it's not quite that easy anymore, as the location of the binary might depend on
the host the computer is run on. (`might depend', because /bin/init would still
be a legitimate path with this filesystem layout.)

There would be a number of ways to go about this issue. One of them would be
by means of a small bootstrap partition or initramfs or similar with appropriate
binaries in a fixed location. This has the advantage of not requiring any
modifications to the kernel itself and it should always work. However, it'd be
quite a pain in the neck to maintain this separate, boot-only filesystem.

An alternative would be making the bootloader pass a parameter to the kernel
with the location of an appropriate init programme. This should be possible by
default with a good deal of popular kernels and bootloaders, such as FreeBSD or
Linux with GRUB or LILO, and is frequently done in practice with systems
employing ``alternative init systems''. Since the bootloader needs to know the
appropriate kernel to execute on the host system anyway, it is very likely that
it would be possible to specify a binary that would at least execute properly on
the target machine.

The kernel itself could also be modified to search for a suitable binary to
execute. This method is fairly invasive, as it requires direct modification of
kernel source code, but it would nevertheless be possible and provide a clean and
final solution to the issue.

\newpage

\begin{thebibliography}{alpha}
\addcontentsline{toc}{section}{References}

\end{thebibliography}

\end{document}
