\documentclass[a4paper,twoside,titlepage]{article}
\usepackage[top=3cm,bottom=3cm,left=3cm,right=3cm]{geometry}
\usepackage{url}

\renewcommand\familydefault{\sfdefault}

\title{Advanced Filesystem Layout}
\author{Magnus Achim Deininger}


\begin{document}
\maketitle
\tableofcontents

\newpage

\section*{Preface}
\addcontentsline{toc}{section}{Preface}
Current filesystem layouts employed by contemporary operating systems suffer
from a number of shortcomings. Among the more common of these are general
inconsistencies and issues with contemporary multi-architecture systems. Minor,
similar issues occur when trying to develop for architectures other than that of
the host system. In general, it is becoming increasingly common that binaries
(executables and libraries) of distinct systems occur together on a single
system. Examples for these would include contemporary desktop systems with
``64-bit'' capabilities mixing binaries compiled for x86-64 and x86-32 on the
same filesystem with poor separation, or average Linux installations containing
binaries intended for Microsoft Windows for use with WINE, or FreeBSD
installations including binaries intended for Linux.

This has lead to what may be perceived as inconsistencies in order to fix some
of these issues, such as the lib/lib32/lib64 dilemma that would require sane
software build scripts to figure out in which of these directories to put
created libraries. This alone is already inconsistent with requirements that
expressly forbid this -32/-64 extension on bin/ directories\footnote{See the FHS
document for details.}, and the idea itself seems rather hackish.

Additionally, the original reasoning behind a split of the root filesystem and
the /usr hierarchy (and also somewhat the /opt and /usr/local hierarchies) seems
to have been to be able to separate machine-local binaries and configuration
from site-local binaries and shared data and read-only from read-write data.
Originally a physical separation between the hierarchies was necessary, but due
to the ability of contemporary operating systems to unify multiple filesystem
hierarchies, sometimes called "union mounts", this division seems quite obsolete
\footnote{Operating Systems such as Plan 9 seem to agree with this.}.

This paper will try to explore an alternative filesystem hierarchy scheme that
should provide consistency for years to come.

\newpage

\section{The Advanced Filesystem Layout}
The general idea behind this filesystem layout is fairly simple: "traditional"
directories are at the end of an arbitrarily long list of host specifications.
This leads to a general layout that looks something like this:
$os/architecture/subarchitecture/(bin|lib)$. The idea is to get more and more
specific along the path, with the operating system being considered less
specific than the hardware architecture. This latter choice is fairly random,
but it seems to be easier or more common to run binaries from a different
architecture on the same operating system than it is to run binaries from a
different operating system even when on the same architecture (although there
are legimitate examples of both).

\newpage

\section{Issues with Legacy Systems}
There are some obvious incompatibilities with legacy filesystem layouts, at
least when employing the more descriptive paths.

\subsection{POSIX Compatibility Considerations}
The most notable problem to be encountered with live multi-host setups is the
likely lack of an appropriate /bin/sh binary. It should be possible to
circumvent this issue with either automatically created symlinks on boot or
with strategic application of namespaces.

It should be noted that this problem is easily be underestimated. Current BSD
and Linux systems, for example, employ a large amount of shell scripting for
common functionality, including things such as the ``init scripts'' that are
responsible for bringing up system services. In these script files, the first
line starts with a shabang, followed by the path to a script interpreter. Since
POSIX guarantees that /bin/sh is a valid shell script interpreter, scripts `out
in the wild' will rely on this and reference this location. The same applies to
the system() function in the standard C library.

\subsection{Booting}
During bootup the kernel needs to find and execute any binaries on the root
filesystem that are required to boot into userspace. With most other fielsystem
layouts, this is easily done, as the binaries were usually always in the same,
so it's just a matter of hardcoding the location, however with this new layout
it's not quite that easy anymore, as the location of the binary might depend on
the host the computer is run on. (`might depend', because /bin/init would still
be a legitimate path with this filesystem layout.)

There would be a number of ways to go about this issue. One of them would be
by means of a small bootstrap partition or initramfs or similar with appropriate
binaries in a fixed location. This has the advantage of not requiring any
modifications to the kernel itself and it should always work. However, it'd be
quite a pain in the neck to maintain this separate, boot-only filesystem.

An alternative would be making the bootloader pass a parameter to the kernel
with the location of an appropriate init programme. This should be possible by
default with a good deal of popular kernels and bootloaders, such as FreeBSD or
Linux with GRUB or LILO, and is frequently done in practice with systems
employing ``alternative init systems''. Since the bootloader needs to know the
appropriate kernel to execute on the host system anyway, it is very likely that
it would be possible to specify a binary that would at least execute properly on
the target machine.

The kernel itself could also be modified to search for a suitable binary to
execute. This method is fairly invasive, as it requires direct modification of
kernel source code, but it would nevertheless be possible and provide a clean and
final solution to the issue.

\newpage

\begin{thebibliography}{alpha}
\addcontentsline{toc}{section}{References}

\end{thebibliography}

\end{document}
